// Called during script initialization
macro gui_initialize
    // DECLARATIONS
    declare ui_label label_global_config (1,1)
    declare ui_menu menu_global_cc_hanging

    // Rules menu and rules buttons
    declare ui_menu menu_rules
    declare ui_button button_add
    declare ui_button button_remove
    declare ui_switch button_rule_bypass
    declare ui_switch button_rule_clone
    // TODO
    // declare ui_button button_sort


    // Rule name
    declare ui_label label_rule_name (1,1)
    declare ui_text_edit @text_rule_name

    // Keyswitch channel
    declare ui_label label_rule_keyswitch_channel (1,1)
    declare ui_menu menu_rule_keyswitch_channel

    // Source Channel (rule default)
    declare ui_label label_rule_source_channel (1,1)
    declare ui_menu menu_rule_source_channel

    // Target Channel (rule default)
    declare ui_label label_rule_target_channel (1,1)
    declare ui_menu menu_rule_target_channel

    // CC chasing behaviour
    declare ui_label label_rule_cc_chasing  (1,1)
    declare ui_menu menu_rule_cc_chasing
    declare ui_label label_rule_cc_chasing_info (1,1)


    // Keyswitches menu and keyswitch buttons
    declare ui_label label_keyswitches (1,1)
    declare ui_menu menu_keyswitches
    declare ui_button button_keyswitch_new
    declare ui_switch button_keyswitch_midi_learn
    declare ui_switch button_keyswitch_midi_learn_inc
    declare ui_switch button_keyswitch_midi_find
    declare ui_button button_keyswitch_clone
    declare ui_button button_keyswitch_remove
    declare ui_button button_keyswitch_clear


    declare ui_label label_rule_keyswitch (1,1)
    declare ui_menu menu_rule_keyswitch_type
    // Key note (when keyswitch type is set to key)
    declare ui_value_edit value_rule_keyswitch_key (0, 127, VALUE_EDIT_MODE_NOTE_NAMES)
    declare ui_label label_rule_keyswitch_velocity_range_from (1,1)
    declare ui_value_edit value_rule_keyswitch_velocity_range_min (0, 127, 1)
    declare ui_label label_rule_keyswitch_velocity_range_to (1,1)
    declare ui_value_edit value_rule_keyswitch_velocity_range_max (0, 127, 1)
    // CC controls (when keyswitch type is set to CC)
    declare ui_value_edit value_rule_keyswitch_cc (0, 127, 1)
    declare ui_label label_rule_keyswitch_cc_value_range_from (1,1)
    declare ui_value_edit value_rule_keyswitch_cc_value_range_min (0, 127, 1)
    declare ui_label label_rule_keyswitch_cc_value_range_to (1,1)
    declare ui_value_edit value_rule_keyswitch_cc_value_range_max (0, 127, 1)
    // Program controls (when redirect type is set to Progran Change)
    declare ui_value_edit value_rule_keyswitch_program (0, 127, 1)

    // Timing feature
    // v3. Timing
    declare ui_label $label_rule_timing(1, 1)
    declare ui_value_edit $value_rule_timing(0, 127, 1)

    // Keyswitch source channel
    declare ui_label label_rule_keyswitch_source_channel (1,1)
    declare ui_menu menu_rule_keyswitch_source_channel

    // Keyswitch target channel
    declare ui_label label_rule_keyswitch_target_channel (1,1)
    declare ui_menu menu_rule_keyswitch_target_channel

    // Keyswitch flags
    declare ui_label label_rule_keyswitch_flags (1,1)
    declare ui_switch switch_rule_keyswitch_flags_hold_notes
    declare ui_switch switch_rule_keyswitch_flags_redirect_only

    // Transpoe
    declare ui_label label_rule_keyswitch_transpose (1,1)
    declare ui_value_edit value_rule_keyswitch_transpose (-64, 64, 1)

    // Keyswitch action menu (block, passthrough, redirect)
    declare ui_label label_rule_keyswitch_action (1,1)
    declare ui_menu menu_rule_keyswitch_action



    // Redirect controls (when action is set to redirect)
    declare ui_label label_rule_keyswitch_redirect_to (1,1)
    declare ui_button button_rule_keyswitch_addremove[MAX_GUI_REDIRECTS_PER_KEYSWITCH]

    // Redirect type menu (key or CC)
    declare ui_menu menu_rule_keyswitch_redirect_type[MAX_GUI_REDIRECTS_PER_KEYSWITCH]

    // Key redirect controls (when redirect type is set to key)
    declare ui_value_edit value_rule_keyswitch_redirect_key[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, VALUE_EDIT_MODE_NOTE_NAMES)
    declare ui_label label_rule_keyswitch_redirect_key_velocity[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (1,1)
    declare ui_value_edit value_rule_keyswitch_redirect_key_velocity[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)

    // CC redirect controls (when redirect type is set to CC)
    declare ui_value_edit value_rule_keyswitch_redirect_cc[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)
    declare ui_label label_rule_keyswitch_redirect_cc_slash[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (1,1)
    declare ui_value_edit value_rule_keyswitch_redirect_cc_value[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)

    // Program redirect controls (when redirect type is set to Progran Change)
    declare ui_value_edit value_rule_keyswitch_redirect_program[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)


    // Keyswitch MIDI Learn button
    declare ui_switch button_rule_keyswitch_redirect_midi_learn[MAX_GUI_REDIRECTS_PER_KEYSWITCH]
    // If not -1, then indicates the index of the keyswitch redirect that's learning.
    declare keyswitch_redirect_midi_learn_index := -1

    declare y := 10
    declare keyswitch_name_update_parallelism := 0

    // CONTROL INITIALIZATION


    make_persistent(menu_rules)
    set_ui_height_px(310 + 20 * MAX_GUI_REDIRECTS_PER_KEYSWITCH)

    init_label(label_global_config, "Global Config ", 70, y, 75)
    menu_global_cc_hanging -> help := "Ensures that, for the specified CCs, zero-values are sent to all channels that had previously received events for these CCs."
    move_and_set_width(menu_global_cc_hanging, 150, y, 150)
    add_menu_item(menu_global_cc_hanging, "Allow CC Hanging", 0)
    add_menu_item(menu_global_cc_hanging, "Prevent hanging for all CCs", 1)
    add_menu_item(menu_global_cc_hanging, "Prevent hanging for CC2/64", 2)
    y := y + 30

    menu_rules -> help := "The list of user defined groups. Up to 16 are allowed."
    move_and_set_width(menu_rules, 70, y, 210)
    for i := 0 to MAX_GUI_RULES - 1
        add_menu_item(menu_rules, rules[i].name, i)
        set_menu_item_visibility(get_ui_id(menu_rules), i, rules[i].config[RULE_DEFINED])
    end for

    button_add -> help := "Add a new keyswitch groups, with all fields initialized to default values."
    set_text(button_add, "Add Group")
    move_and_set_width(button_add, 290, y, 60)

    button_remove -> help := "Remove the current group. If there's only one group, then it's reinitialized to default values."
    set_text(button_remove, "Remove Group")
    move_and_set_width(button_remove, 360, y, 80)

    button_rule_bypass -> help := "Disable all keyswitches associated with this group."
    set_text(button_rule_bypass, "Bypass Group")
    move_and_set_width(button_rule_bypass, 450, y, 75)
    center(button_rule_bypass)

    button_rule_clone -> help := "Creates a new group, copying all settings and keyswitches from this group."
    set_text(button_rule_clone, "Clone Group")
    move_and_set_width(button_rule_clone, 535, y, 75)
    center(button_rule_clone)

    // set_text(button_sort, "Sort Rules")
    // move_and_set_width(button_sort, 430, y, 60)

    y := y + 30
    init_label(label_rule_name, "Group Name", 95, y, 95)
    text_rule_name -> help := "An aribitrary name for this group. Be descriptive!"
    move_and_set_width(text_rule_name, 200, y, 190)

    y := y + 20
    menu_rule_keyswitch_channel -> help := "The channel on which all keyswitch events will be received. Omni means keyswitches will work on any channel."
    init_label(label_rule_keyswitch_channel, "Keyswitch Channel", 95, y, 95)
    add_menu_item(menu_rule_keyswitch_channel, "Omni", -1)
    move_and_set_width(menu_rule_keyswitch_channel, 200, y, 60)
    init_channel_menu(menu_rule_keyswitch_channel, 16)

    y := y + 20
    menu_rule_source_channel -> help := "Once a keyswitch is triggered and routes established, this is the default channel for the group on which all MIDI events will be routed to the target channel(s). Individual keyswitches can override this."
    init_label(label_rule_source_channel, "Default Source", 95, y, 95)
    move_and_set_width(menu_rule_source_channel, 200, y, 60)
    add_menu_item(menu_rule_source_channel, "Omni", -1)
    init_channel_menu(menu_rule_source_channel, 16)

    y := y + 20
    menu_rule_target_channel -> help := "Once a keyswitch is triggered, this is the default channel for the group to which all subsequent non-keyswitch events will be routed. Individual keyswitches can override this."
    init_label(label_rule_target_channel, "Default Target", 95, y, 95)
    move_and_set_width(menu_rule_target_channel, 200, y, 60)
    add_menu_item(menu_rule_target_channel, "Null", -1)
    init_channel_menu(menu_rule_target_channel, 64)

    y := y + 20
    menu_rule_cc_chasing -> help := "When activing keyswitches, replays the state of the given CCs to the new target channel(s). This can ensure a smooth transition between patches."
    init_label(label_rule_cc_chasing, "CC Chasing", 95, y, 95)
    move_and_set_width(menu_rule_cc_chasing, 200, y, 125)
    add_menu_item(menu_rule_cc_chasing, "No chasing", 0)
    add_menu_item(menu_rule_cc_chasing, "Chase all CCs", 1)
    add_menu_item(menu_rule_cc_chasing, "Chase common CCs", 2)
    init_info_label(label_rule_cc_chasing_info, 9, "This is info about CC chasing.", 325, y, 150)

    y := y + 30
    init_label(label_keyswitches, "Keyswitches", 95, y, 95)

    menu_keyswitches -> help := "The list of configured keyswitches for the current group. Up to 127 keyswitches are allowed per group."
    move_and_set_width(menu_keyswitches, 200, y, 100)
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        add_menu_item(menu_keyswitches, "", i)
    end for

    button_keyswitch_new -> help := "Create a new keyswitch, whose configuration is initialized to hopefully something intelligent based on context."
    set_text(button_keyswitch_new, "New")
    move_and_set_width(button_keyswitch_new, 310, y, 35)

    button_keyswitch_midi_learn -> help :="MIDI learn a keyswitch (note, CC, or program change).  Duplicates are prevented -- if you want duplicates, you need to manually create them with the New or Clone buttons."
    set_text(button_keyswitch_midi_learn, "Learn")
    move_and_set_width(button_keyswitch_midi_learn, 350, y, 40)

    button_keyswitch_midi_learn_inc -> help := "Same as the Learn button, except the keyswitch config is initialized to values based on the relative distance between the current and newly learned keyswitches."
    set_text(button_keyswitch_midi_learn_inc, "Learn++")
    move_and_set_width(button_keyswitch_midi_learn_inc, 395, y, 50)

    button_keyswitch_midi_find -> help := "Find a keyswitch based on MIDI input. Don't forget to toggle this off when you're done searching!"
    set_text(button_keyswitch_midi_find, "MIDI Find")
    move_and_set_width(button_keyswitch_midi_find, 450, y, 55)

    button_keyswitch_clone -> help := "Create a new keyswitch with identical configuration."
    set_text(button_keyswitch_clone, "Clone")
    move_and_set_width(button_keyswitch_clone, 510, y, 35)

    button_keyswitch_remove -> help := "Remove the currently selected keyswitch from the group."
    set_text(button_keyswitch_remove, "Remove")
    move_and_set_width(button_keyswitch_remove, 550, y, 45)

    // Remove Clear button for now.  Debating if this is worth having.
    hide(button_keyswitch_clear)
    //set_text(button_keyswitch_clear, "Clear All")
    //move_and_set_width(button_keyswitch_clear, 560, y, 50)
    //center(button_keyswitch_clear)


    y := y + 20
    init_label(label_rule_keyswitch, "Keyswitch", 135, y, 55)

    menu_rule_keyswitch_type -> help := "Defines the type of keyswitch: either a note, a CC event, or Program Change."
    move_and_set_width(menu_rule_keyswitch_type, 200, y, 40)
    add_menu_item(menu_rule_keyswitch_type, "Key", 0)
    add_menu_item(menu_rule_keyswitch_type, "CC", 1)
    add_menu_item(menu_rule_keyswitch_type, "Prog", 2)

    value_rule_keyswitch_key -> help := "Receiving this note on the group's keyswitch channel will trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_key, 245, y, 40)
    set_text(value_rule_keyswitch_key, "")

    set_label_properties(label_rule_keyswitch_velocity_range_from, "with velocity", 0, 1)
    set_bounds(label_rule_keyswitch_velocity_range_from, 290, y, 70)

    value_rule_keyswitch_velocity_range_min -> help := "Minimum velocity for the keyswitch note. Lower velocities will not trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_velocity_range_min, 365, y, 35)
    set_text(value_rule_keyswitch_velocity_range_min, "")

    set_label_properties(label_rule_keyswitch_velocity_range_to, "to", 0, 1)
    set_bounds(label_rule_keyswitch_velocity_range_to, 405, y, 25)

    value_rule_keyswitch_velocity_range_max -> help := "Maxinum velocity for the keyswitch note. Higher velocities will not trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_velocity_range_max, 435, y, 35)
    set_text(value_rule_keyswitch_velocity_range_max, "")

    value_rule_keyswitch_cc -> help := "The CC number that must be received on the group's keyswitch channel to trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_cc, 245, y, 35)
    set_text(value_rule_keyswitch_cc, "")
    set_label_properties(label_rule_keyswitch_cc_value_range_from, "with values", 0, 1)
    set_bounds(label_rule_keyswitch_cc_value_range_from, 285, y, 65)

    value_rule_keyswitch_cc_value_range_min -> help := "The minimum CC value that must be matched to trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_cc_value_range_min, 355, y, 35)
    set_text(value_rule_keyswitch_cc_value_range_min, "")

    set_label_properties(label_rule_keyswitch_cc_value_range_to, "to", 0, 1)
    set_bounds(label_rule_keyswitch_cc_value_range_to, 395, y, 25)

    value_rule_keyswitch_cc_value_range_max -> help := "The maximum CC value that must be matched to trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_cc_value_range_max, 425, y, 35)
    set_text(value_rule_keyswitch_cc_value_range_max, "")

    value_rule_keyswitch_program -> help := "The program change number that will trigger the keyswitch when received on the group's keyswitch channel."
    move_and_set_width(value_rule_keyswitch_program, 245, y, 35)
    set_text(value_rule_keyswitch_program, "")

    // Timing feature
    // v3. Timing
    y := y + 20
    value_rule_timing -> help := "Timing feature"
    init_label(label_rule_timing, "Timing", 135, y, 55)
    move_and_set_width(value_rule_timing, 200, y, 60)
    set_text(value_rule_timing,"ms ")
    
    y := y
    init_label(label_rule_keyswitch_transpose, "Transpose", 270, y, 55)
    move_and_set_width(value_rule_keyswitch_transpose, 330, y, 35)
    value_rule_keyswitch_transpose -> help := "Number of semitones to transpose incoming notes after the keyswitch is triggered."
    set_text(value_rule_keyswitch_transpose, "")

    y := y + 20
    menu_rule_keyswitch_source_channel -> help := "Override the group-default source channel. When this keyswitch is engaged, MIDI events on this channel will be routed to the target channel. Default means use the group default above."
    init_label(label_rule_keyswitch_source_channel, "Source", 135, y, 55)
    move_and_set_width(menu_rule_keyswitch_source_channel, 200, y, 60)
    add_menu_item(menu_rule_keyswitch_source_channel, "Default", 0)
    add_menu_item(menu_rule_keyswitch_source_channel, "Omni", -1)
    init_channel_menu(menu_rule_keyswitch_source_channel, 16)

    y := y + 20
    menu_rule_keyswitch_target_channel -> help := "Override the group-default target channel. When this keyswitch is engaged, MIDI events will be routed to this channel.  Null is a special case which blackholes all incoming MIDI events on the source channel when this keyswitch is active."
    init_label(label_rule_keyswitch_target_channel, "Target", 135, y, 55)
    move_and_set_width(menu_rule_keyswitch_target_channel, 200, y, 60)
    add_menu_item(menu_rule_keyswitch_target_channel, "Default", 0)
    add_menu_item(menu_rule_keyswitch_target_channel, "Null", -1)
    init_channel_menu(menu_rule_keyswitch_target_channel, 64)

    y := y + 20
    init_label(label_rule_keyswitch_flags, "Options", 135, y, 55)

    switch_rule_keyswitch_flags_hold_notes -> help := "When enabled, note redirections (see keyswitch action) will be held until the next keyswitch activation. Useful for patches that engage functionality only while a particular note is pressed."
    set_text(switch_rule_keyswitch_flags_hold_notes, "Hold redirected notes until next keyswitch")
    move_and_set_width(switch_rule_keyswitch_flags_hold_notes, 200, y, 200)
    center(switch_rule_keyswitch_flags_hold_notes)

    switch_rule_keyswitch_flags_redirect_only -> help := "When enabled, triggering the keyswitch will not affect routing of subsequent MIDI events, which is useful for processing redirections only, or blocking keyswitches."
    set_text(switch_rule_keyswitch_flags_redirect_only, "Ignore routing")
    move_and_set_width(switch_rule_keyswitch_flags_redirect_only, 410, y, 80)
    center(switch_rule_keyswitch_flags_redirect_only)

    y := y + 20

    init_label(label_rule_keyswitch_action, "KS Action", 135, y, 55)

    menu_rule_keyswitch_action -> help := "Defines the action to take when the keyswitch is triggered. Block prevents the keyswitch from reaching the target channel. Passthrough will route the keyswitch as-is to the target. Redirect allows user-customizable translation to the target."
    move_and_set_width(menu_rule_keyswitch_action, 200, y, 80)
    add_menu_item(menu_rule_keyswitch_action, "Block", KEYSWITCH_ACTION_BLOCK)
    add_menu_item(menu_rule_keyswitch_action, "Passthrough", KEYSWITCH_ACTION_PASSTHROUGH)
    add_menu_item(menu_rule_keyswitch_action, "Redirect", KEYSWITCH_ACTION_REDIRECT)

    set_label_properties(label_rule_keyswitch_redirect_to, "to", 0, 1)
    set_bounds(label_rule_keyswitch_redirect_to, 285, y, 25)

    iterate_macro(configure_keyswitch_redirect_controls) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
    // The first redirect add/remove button is just a dummy/placeholder, so hide it.
    button_rule_keyswitch_addremove[0] -> hide := HIDE_WHOLE_CONTROL

    y := y - 80

    read_persistent_var(menu_rules)
    gui_update_for_selected_rule()
end macro

macro configure_keyswitch_redirect_controls(#n#)
    if #n# > 0
        button_rule_keyswitch_addremove#n# -> help := "Add or remove a redirection target"
        set_button_properties(button_rule_keyswitch_addremove[#n#], "+")
        button_rule_keyswitch_addremove[#n#] -> text_alignment := 1
        set_bounds(button_rule_keyswitch_addremove[#n#], 285, y, 25)
    end if

    menu_rule_keyswitch_redirect_type#n# -> help := "Defines the type of MIDI event the keyswitch will be redirected to. Either a note, CC event, or program change."
    set_bounds(menu_rule_keyswitch_redirect_type[#n#], 315, y, 40)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "Key", 0)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "CC", 1)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "Prog", 2)

    value_rule_keyswitch_redirect_key#n# -> help := "The note the keyswitch will send to the target channel."
    move_and_set_width(value_rule_keyswitch_redirect_key#n#, 360, y, 40)
    set_text(value_rule_keyswitch_redirect_key#n#, "")

    value_rule_keyswitch_redirect_key_velocity#n# -> help := "The velocity of the note."
    init_label(label_rule_keyswitch_redirect_key_velocity#n#, "Velocity", 400, y, 45)
    center(label_rule_keyswitch_redirect_key_velocity#n#)
    move_and_set_width(value_rule_keyswitch_redirect_key_velocity#n#, 445, y, 35)
    set_text(value_rule_keyswitch_redirect_key_velocity#n#, "")

    value_rule_keyswitch_redirect_cc#n# -> help := "The CC number of the redirected MIDI event."
    move_and_set_width(value_rule_keyswitch_redirect_cc#n#, 360, y, 35)

    set_text(value_rule_keyswitch_redirect_cc#n#, "")
    init_label(label_rule_keyswitch_redirect_cc_slash#n#, "/", 395, y, 15)

    value_rule_keyswitch_redirect_cc_value#n# -> help := "The CC value of the redirected MIDI event."
    move_and_set_width(value_rule_keyswitch_redirect_cc_value#n#, 410, y, 35)
    set_text(value_rule_keyswitch_redirect_cc_value#n#, "")

    value_rule_keyswitch_redirect_program#n# -> help := "The program change number to send to the target channel."
    move_and_set_width(value_rule_keyswitch_redirect_program#n#, 360, y, 35)
    set_text(value_rule_keyswitch_redirect_program#n#, "")

    button_rule_keyswitch_redirect_midi_learn#n# -> help := "MIDI learn a redirection event."
    set_text(button_rule_keyswitch_redirect_midi_learn#n#, "MIDI Learn")
    move_and_set_width(button_rule_keyswitch_redirect_midi_learn#n#, 485, y, 60)

    y := y + 20
end macro

function init_channel_menu(menu, channels)
    for i := 1 to channels
        name := get_midi_channel_name(i)
        add_menu_item(menu, name, i)
    end for
end function

// CONVENIENCE MACROS

macro move(control, x, y)
    control -> pos_x := x
    control -> pos_y := y
end macro

macro move_and_set_width(control, x, y, w)
    move(control, x, y)
    control -> width := w
end macro

macro init_label(label, text, x, y, w)
    set_text(label, text)
    move_and_set_width(label, x, y, w)
    label -> text_alignment := 2
end macro

macro init_info_label(label, font, text, x, y, w)
    init_label(label, text, x, y, w)
    label -> hide := HIDE_PART_BG
    label -> text_alignment := 0
    label -> font_type := font
end macro

macro hide(control)
    control -> hide := HIDE_WHOLE_CONTROL
end macro

macro show(control)
    control -> hide := HIDE_PART_NOTHING
end macro

macro center(control)
    control -> text_alignment := 1
end macro

// GUI FUNCTIONS


// Returns the index of the selected rule in the UI
function gui_get_selected_rule() -> idx
    idx := menu_rules -> selected_item_idx
end function


// Returns the index of the selected keyswitch in the UI (within the context of the selected rule)
function gui_get_selected_keyswitch() -> idx
    idx := menu_keyswitches -> selected_item_idx
end function


// Given a channel number, update the given label with the human readable channel name.
function _gui_set_channel_info_label(label, channel)
    name := get_midi_channel_name(channel)
    set_text(label, name)
end function


// Adjusts all the UI elements to reflect the currently selected item in the rules menu.
function gui_update_for_selected_rule()
    rule := gui_get_selected_rule()
    text_rule_name := rules[rule].name

    menu_global_cc_hanging := global_config[GLOBAL_CONFIG_CC_HANGING]
    menu_rule_keyswitch_channel := rules[rule].config[RULE_KEYSWITCH_CHANNEL]
    menu_rule_source_channel := rules[rule].config[RULE_SOURCE_CHANNEL]
    menu_rule_target_channel := rules[rule].config[RULE_TARGET_CHANNEL]
    menu_rule_cc_chasing := rules[rule].config[RULE_CC_CHASING]
    if menu_rule_cc_chasing = 2
        set_text(label_rule_cc_chasing_info, "Chases CCs 1, 2, 11, 64-69")
    else
        set_text(label_rule_cc_chasing_info, "")
    end if

    button_rule_bypass := 1 - rules[rule].config[RULE_ENABLED]
    menu_keyswitches := 0
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        ks := rules[rule].keyswitch[i].evcode
        if ks # KEYSWITCH_UNDEFINED
            name := get_keyswitch_name(ks, rules[rule].keyswitch[i].velocity._raw)
            set_menu_item_str(get_ui_id(menu_keyswitches), i, name)
            set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 1)
        else
            set_menu_item_str(get_ui_id(menu_keyswitches), i, "<empty>")
            if i > 0
                set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 0)
            end if
       end if
    end for
    gui_update_for_selected_keyswitch()
end function


// Set visibility of all controls in the keyswitch section by context of the keyswitch configuration.
function gui_set_keyswitch_section_visibility(rule, idx, ks, action)
    // section control, ks note controls, ks cc controls, ks program controls, section info label
    declare params[9]
    macro reset_params()
        for j := 0 to 8
            params[j] := HIDE_WHOLE_CONTROL
        end for
    end macro
    reset_params()
    if ks # KEYSWITCH_UNDEFINED
        params[0] := HIDE_PART_NOTHING
        params[4] := HIDE_PART_BG
        if ks < 128
            params[1] := HIDE_PART_NOTHING
        else if ks < 256
            params[3] := HIDE_PART_NOTHING
        else
            params[2] := HIDE_PART_NOTHING
        end if
    end if

    label_rule_keyswitch -> hide := params[0]
    menu_rule_keyswitch_type -> hide := params[0]
    label_rule_keyswitch_action -> hide := params[0]
    menu_rule_keyswitch_action -> hide := params[0]

    value_rule_keyswitch_key -> hide := params[1]
    label_rule_keyswitch_velocity_range_from -> hide := params[1]
    value_rule_keyswitch_velocity_range_min -> hide := params[1]
    label_rule_keyswitch_velocity_range_to -> hide := params[1]
    value_rule_keyswitch_velocity_range_max -> hide := params[1]

    value_rule_keyswitch_cc -> hide := params[2]
    label_rule_keyswitch_cc_value_range_from -> hide := params[2]
    value_rule_keyswitch_cc_value_range_min -> hide := params[2]
    label_rule_keyswitch_cc_value_range_to -> hide := params[2]
    value_rule_keyswitch_cc_value_range_max -> hide := params[2]
    value_rule_keyswitch_program -> hide := params[3]

    label_rule_keyswitch_source_channel -> hide := params[0]
    menu_rule_keyswitch_source_channel -> hide := params[4]
    label_rule_keyswitch_target_channel -> hide := params[0]
    menu_rule_keyswitch_target_channel -> hide := params[4]
    label_rule_keyswitch_flags -> hide := params[0]
    label_rule_timing -> hide := params[0]
    value_rule_timing -> hide := params[0]
    switch_rule_keyswitch_flags_hold_notes -> hide := params[4]
    switch_rule_keyswitch_flags_redirect_only -> hide := params[4]
    label_rule_keyswitch_transpose -> hide := params[0]
    value_rule_keyswitch_transpose -> hide := params[0]

    for i := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
        // Initialize show/hide parameters based on keyswitch config context
        reset_params()
        evcode := rules[rule].keyswitch[idx].redirects[i].evcode
        if action = KEYSWITCH_ACTION_REDIRECT
            if evcode # KEYSWITCH_UNDEFINED
                params[0] := HIDE_PART_NOTHING
                if evcode < 128
                    params[1] := HIDE_PART_NOTHING
                else if evcode < 256
                    params[3] := HIDE_PART_NOTHING
                else
                    params[2] := HIDE_PART_NOTHING
                end if
            end if
        end if

        if i = 0
            label_rule_keyswitch_redirect_to -> hide := params[0]
        else
            if evcode # KEYSWITCH_UNDEFINED and action = KEYSWITCH_ACTION_REDIRECT
                set_button_properties(button_rule_keyswitch_addremove[i], "-")
                button_rule_keyswitch_addremove[i] -> hide := HIDE_PART_NOTHING
            else
                set_button_properties(button_rule_keyswitch_addremove[i], "+")
                // If the previous keyswitch redirect is defined, show the button.
                if rules[rule].keyswitch[idx].redirects[i - 1].evcode # KEYSWITCH_UNDEFINED and ...
                    action = KEYSWITCH_ACTION_REDIRECT
                    button_rule_keyswitch_addremove[i] -> hide := HIDE_PART_NOTHING
                else
                    button_rule_keyswitch_addremove[i] -> hide := HIDE_WHOLE_CONTROL
                end if
            end if
        end if

        menu_rule_keyswitch_redirect_type[i] -> hide := params[0]
        value_rule_keyswitch_redirect_key[i] -> hide := params[1]
        label_rule_keyswitch_redirect_key_velocity[i] -> hide := params[1]
        value_rule_keyswitch_redirect_key_velocity[i] -> hide := params[1]

        value_rule_keyswitch_redirect_cc[i] -> hide := params[2]
        label_rule_keyswitch_redirect_cc_slash[i] -> hide := params[2]
        value_rule_keyswitch_redirect_cc_value[i] -> hide := params[2]

        value_rule_keyswitch_redirect_program[i] -> hide := params[3]
        button_rule_keyswitch_redirect_midi_learn[i] -> hide := params[0]
    end for
end function

// Updates the current keyswitch menu label based on the current defined keyswitch.
function gui_update_keyswitch_name
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    ks := rules[rule].keyswitch[idx].evcode
    name := get_keyswitch_name(ks, rules[rule].keyswitch[idx].velocity._raw)
    set_menu_item_str(get_ui_id(menu_keyswitches), idx, name)
end function

// A deferred version of above, to mitigate a UX problem when adjusting value controls
// that affect the keyswitch name.  The menu item will be updated after 500ms of
// inactivity.
function gui_update_keyswitch_name_defer
    keyswitch_name_update_parallelism := keyswitch_name_update_parallelism + 1
    wait(500000)
    keyswitch_name_update_parallelism := keyswitch_name_update_parallelism - 1
    if keyswitch_name_update_parallelism = 0
        call gui_update_keyswitch_name
    end if
end function


// Adjusts all the UI elements to reflect the currently selected keyswitch (for the current rule)
function gui_update_for_selected_keyswitch()
    rule := gui_get_selected_rule()
    count := get_num_keyswitches_for_rule(rule)

    if count > 0
        idx := gui_get_selected_keyswitch()
        ks := rules[rule].keyswitch[idx].evcode
        action := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
        flag := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS]

        if ks # KEYSWITCH_UNDEFINED
            if ks < 128
                value_rule_keyswitch_velocity_range_min := rules[rule].keyswitch[idx].velocity.min
                value_rule_keyswitch_velocity_range_max := rules[rule].keyswitch[idx].velocity.max
            else if ks > 128*128
                // CC
                value_rule_keyswitch_cc_value_range_min := rules[rule].keyswitch[idx].velocity.min
                value_rule_keyswitch_cc_value_range_max := rules[rule].keyswitch[idx].velocity.max
            end if
            menu_rule_keyswitch_source_channel := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
            menu_rule_keyswitch_target_channel := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TARGET_CHANNEL]
            value_rule_keyswitch_transpose := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TRANSPOSE]
            value_rule_timing := rules[rule].keyswitch[idx].config[RULE_TIMING]
            switch_rule_keyswitch_flags_hold_notes := flag .and. KEYSWITCH_FLAG_HOLD_NOTES
            switch_rule_keyswitch_flags_redirect_only := flag .and. KEYSWITCH_FLAG_IGNORE_ROUTING
        end if

        gui_set_keyswitch_section_visibility(rule, idx, ks, action)

        if ks < 128
            menu_rule_keyswitch_type := 0
            value_rule_keyswitch_key := ks
        else if ks < 256
            menu_rule_keyswitch_type := 2
            value_rule_keyswitch_program := ks - 128
        else if ks # KEYSWITCH_UNDEFINED
            menu_rule_keyswitch_type := 1
            value_rule_keyswitch_cc := ks / 128 - 128
            // value_rule_keyswitch_cc_value_range_min := ks mod 128
        end if

        menu_rule_keyswitch_action := action

        if action = KEYSWITCH_ACTION_REDIRECT
            macro update_keyswitch_redirect(#n#)
                evcode := rules[rule].keyswitch[idx].redirects[#n#].evcode
                if evcode < 128
                    velocity := rules[rule].keyswitch[idx].redirects[#n#].velocity
                    value_rule_keyswitch_redirect_key#n# := evcode
                    menu_rule_keyswitch_redirect_type#n# := 0
                    value_rule_keyswitch_redirect_key_velocity#n# := velocity
                else if evcode < 256
                    menu_rule_keyswitch_redirect_type#n# := 2
                    value_rule_keyswitch_redirect_program#n# := evcode - 128
                else if evcode # KEYSWITCH_UNDEFINED
                    menu_rule_keyswitch_redirect_type#n# := 1
                    value_rule_keyswitch_redirect_cc#n# := evcode / 128 - 128
                    value_rule_keyswitch_redirect_cc_value#n# := evcode mod 128
                end if
            end macro
            iterate_macro(update_keyswitch_redirect) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
        end if
    else
        gui_set_keyswitch_section_visibility(rule, 0, KEYSWITCH_UNDEFINED, 0)
    end if
end function


// Sets the given config parameter for the currently selected rule.
function gui_set_selected_rule_config(config, value)
    rule := gui_get_selected_rule()
    rules[rule].config[config] := value
    need_maps_rebuild := 1
end function


// Clears all active routes and informs user via a message.  Must be called when a UI
// element is changed that would invalidate the current routes.
function gui_clear_active_routes_for_all_channels()
    for j := 0 to NUM_SOURCE_CHANNELS - 1
        clear_active_routes_for_channel(j)
    end for
    message("Active keyswitches cleared due to rule change.  Keyswitches must be retriggered.")
end function


// Adds the given keyswitch number to the currently selected rule.  Triggered by MIDI learn and the
// New and Clone buttons. This function understands the UI context (which button was pressed)
// and acts accordingly.

// Caller must set ks variable to the request keyswitch evcode.
function gui_append_keyswitch_to_selected_rule
    rule := gui_get_selected_rule()

    if ks # KEYSWITCH_UNDEFINED
        // Do not allow MIDI Learn to create duplicates of a keyswitch. (Though
        // that can be done manually.)
        idx := get_keyswitch_idx_for_rule(rule, ks, -1)
    else
        idx := -1
    end if

    if idx = -1
        // Determine the currently selected keyswitch in the GUI for later.
        idx := gui_get_selected_keyswitch()
        count := get_num_keyswitches_for_rule(rule)
        velocity := VELOCITY_RANGE_DEFAULT
        if ks = KEYSWITCH_UNDEFINED
            if count > 0
                if button_keyswitch_clone = 1
                    ks := rules[rule].keyswitch[idx].evcode
                else
                    ks := rules[rule].keyswitch[idx].evcode + 1
                end if
                velocity := rules[rule].keyswitch[idx].velocity._raw
            else
                // No existing keyswitches, use first note.
                ks := 0
            end if
        else if ks < 128 and button_keyswitch_midi_learn_inc = 1 and count > 0
            // Copy velocity to new keyswitch learned via
            velocity := rules[rule].keyswitch[idx].velocity._raw
        else if ks > 128*128
            // For learned CCs, set range min/max to CC value.
            value := ks mod 128
            velocity := value + sh_left(value, 8)
        end if

        if count < MAX_KEYSWITCHES_PER_RULE
            name := get_keyswitch_name(ks, velocity)
            set_menu_item_str(get_ui_id(menu_keyswitches), count, name)
            set_menu_item_visibility(get_ui_id(menu_keyswitches), count, 1)
            rules[rule].keyswitch[count].evcode := ks
            rules[rule].keyswitch[count].velocity._raw := velocity
            menu_keyswitches := count

            if count > 0
                // Clone some config from the currently selected keyswitch
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_FLAGS] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_ACTION] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TARGET_CHANNEL] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TARGET_CHANNEL]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TRANSPOSE] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TRANSPOSE]
                rules[rule].keyswitch[count].config[RULE_TIMING] := rules[rule].keyswitch[idx].config[RULE_TIMING]

                // If the currently selected keyswitch we're cloning is a redirect and the Learn++
                // button was pressed, rather than cloning the redirect config directly, measure the
                // distance between the new keyswitch and the currently selected keyswitch and
                // adjust the redirection based on the distance.
                action := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
                if action = KEYSWITCH_ACTION_REDIRECT
                    if button_keyswitch_midi_learn_inc = 1
                        offset := ks - rules[rule].keyswitch[idx].evcode
                    else
                        offset := 0
                    end if

                    for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                        evcode := rules[rule].keyswitch[idx].redirects[i].evcode
                        if evcode # KEYSWITCH_UNDEFINED
                            // Now configure the new keyswitch with the adjusted redirect and the
                            // source/target channels of the cloned keyswitch.
                            rules[rule].keyswitch[count].redirects[i].evcode := evcode + offset
                            value := rules[rule].keyswitch[idx].redirects[i].velocity
                            rules[rule].keyswitch[count].redirects[i].velocity := value
                        else
                            rules[rule].keyswitch[count].redirects[i].evcode := KEYSWITCH_UNDEFINED
                        end if
                    end for
                end if
            else
                // Initialize new keyswitch (not cloned) to blocked, all source channels,
                // rule default target channel.
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_FLAGS] := 0
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := 0
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TARGET_CHANNEL] := 0
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TRANSPOSE] := 0
                rules[rule].keyswitch[count].config[RULE_TIMING] := 0

                for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                    rules[rule].keyswitch[count].redirects[i].evcode := KEYSWITCH_UNDEFINED
                end for
            end if
            call gui_update_for_selected_keyswitch
            message("Added keyswitch " & name & " to rule " & rules[rule].name & " at index " & count)
        else
            message("ERROR: too many keyswitches for this rule, can't add.")
        end if
        need_maps_rebuild := 1
    else
        // Keyswitch already exists, so select it in UI instead
        menu_keyswitches := idx
        call gui_update_for_selected_keyswitch
    end if
end function


// Removes all keyswitches for the current rule.
function gui_clear_keyswitches_for_selected_rule()
    rule := gui_get_selected_rule()
    menu_keyswitches := 0
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        rules[rule].keyswitch[i].evcode := KEYSWITCH_UNDEFINED
        rules[rule].keyswitch[i].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
        set_menu_item_str(get_ui_id(menu_keyswitches), i, "<empty>")
        if i > 0
            set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 0)
        end if
    end for
    call gui_clear_active_routes_for_all_channels
    call gui_update_for_selected_keyswitch
end function


// Sets the given config parameter for the currently selected keyswitch.
function gui_set_selected_keyswitch_config(config, value)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    // If setting the keyswitch action to redirect, then ensure the first
    // keyswitch redirect is initialized.
    if config = RULE_KEYSWITCH_ACTION and value = KEYSWITCH_ACTION_REDIRECT
        if rules[rule].keyswitch[idx].redirects[0].evcode = KEYSWITCH_UNDEFINED
            rules[rule].keyswitch[idx].redirects[0].evcode := 0
            rules[rule].keyswitch[idx].redirects[0].velocity := 127
        end if
    end if
    rules[rule].keyswitch[idx].config[config] := value
end function

// Sets a redirect for the currently selected keyswitch.
function gui_set_selected_keyswitch_config_redirect(n, ks, velocity)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    if ks >= 0
        rules[rule].keyswitch[idx].redirects[n].evcode := ks
    end if
    if velocity >= 0
        rules[rule].keyswitch[idx].redirects[n].velocity := velocity
    end if
end function

// Sets the given config parameter for the currently selected keyswitch.
function gui_set_selected_keyswitch_config_flags(flag, state)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    value := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS] .and. .not. flag
    if state # 0
        value := value .or. flag
    end if
    rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS] := value
end function


// Updates the UI to show the given keyswitch as selected.  Triggered by MIDI Find.
function gui_set_selected_keyswitch_by_ks(ks, velocity)
    rule := gui_get_selected_rule()
    idx := get_keyswitch_idx_for_rule(rule, ks, velocity)
    if idx # -1
        menu_keyswitches := idx
        call gui_update_for_selected_keyswitch
    else
        name := get_keyswitch_name(ks, velocity + sh_left(velocity, 8))
        message("Keyswitch " & name & " not found for this rule")
    end if
end function



// Configures the active keyswitch parameters from the current UI settings
function gui_set_selected_keyswitch_from_ui
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    ks := rules[rule].keyswitch[idx].evcode

    // This is far uglier than it should have to be.  But we need to do all this lame
    // comparison of current values to determine if gui_update_keyswitch_name_defer()
    // actually needs to be called, because if we call set_menu_item_str it changes
    // control focus and breaks UX.
    //
    // If 1, it means the values have actually changed.
    flag := 0
    if menu_rule_keyswitch_type = 0
         // Key
        if ks # value_rule_keyswitch_key or rules[rule].keyswitch[idx].velocity.min # value_rule_keyswitch_velocity_range_min or ...
           rules[rule].keyswitch[idx].velocity.max # value_rule_keyswitch_velocity_range_max
            flag := 1
            rules[rule].keyswitch[idx].evcode := value_rule_keyswitch_key
            rules[rule].keyswitch[idx].velocity.min := value_rule_keyswitch_velocity_range_min
            rules[rule].keyswitch[idx].velocity.max := value_rule_keyswitch_velocity_range_max
        end if
    else if menu_rule_keyswitch_type = 2
        // Program
        evcode := 128 + value_rule_keyswitch_program
        if ks # evcode
            flag := 1
            rules[rule].keyswitch[idx].evcode := evcode
        end if
    else
        // CCs with value ranges have the CC value as 0 in the evcode, to indicate the range needs
        // to be checked.
        evcode := 128*128 + value_rule_keyswitch_cc * 128
        if value_rule_keyswitch_cc_value_range_min = value_rule_keyswitch_cc_value_range_max
            evcode := evcode + value_rule_keyswitch_cc_value_range_min
        end if
        if ks # evcode or rules[rule].keyswitch[idx].velocity.min # value_rule_keyswitch_cc_value_range_min or ...
           rules[rule].keyswitch[idx].velocity.max # value_rule_keyswitch_cc_value_range_max
            flag := 1
            rules[rule].keyswitch[idx].evcode := evcode
            rules[rule].keyswitch[idx].velocity.min := value_rule_keyswitch_cc_value_range_min
            rules[rule].keyswitch[idx].velocity.max := value_rule_keyswitch_cc_value_range_max
        end if
    end if
    if flag = 1
        // Only update GUI if there were changes.
        call gui_update_for_selected_keyswitch
        call gui_update_keyswitch_name_defer
    end if
end function


function clear_redirect_midi_learn_buttons
    macro _clear_redirect_midi_learn_buttons(#n#)
        button_rule_keyswitch_redirect_midi_learn#n# := 0
    end macro
    iterate_macro(_clear_redirect_midi_learn_buttons) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
    keyswitch_redirect_midi_learn_index := -1
    button_keyswitch_midi_find := 0
    button_keyswitch_midi_learn_inc := 0
    button_keyswitch_midi_learn := 0

end function

// Configures the redirect keyswitch for the currently selected keyswitch.  Triggered
// by keyswitch MIDI Learn.
function gui_set_selected_keyswitch_redirect(ks, value)
    gui_set_selected_keyswitch_config_redirect(keyswitch_redirect_midi_learn_index, ks, value)
    call clear_redirect_midi_learn_buttons
    call gui_update_for_selected_keyswitch
    need_maps_rebuild := 1
end function


// Configures the active keyswitch redirection parameters from the current UI settings
function gui_set_selected_keyswitch_redirect_from_ui
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    macro update_keyswitch_config_redirect(#n#)
        if menu_rule_keyswitch_redirect_type[#n#] -> hide = HIDE_WHOLE_CONTROL
            // If the keyswitch type menu is hidden, then keyswitch is undefined.
            ks := KEYSWITCH_UNDEFINED
        else if menu_rule_keyswitch_redirect_type#n# = 0
             // Key
            ks := value_rule_keyswitch_redirect_key#n#
        else if menu_rule_keyswitch_redirect_type#n# = 1
            // CC
            ks := 128*128 + value_rule_keyswitch_redirect_cc#n# * 128 + value_rule_keyswitch_redirect_cc_value#n#
        else if menu_rule_keyswitch_redirect_type#n# = 2
            // Program
            ks := 128 + value_rule_keyswitch_redirect_program#n#
        else
            ks := KEYSWITCH_UNDEFINED
        end if
        rules[rule].keyswitch[idx].redirects[#n#].evcode := ks
        rules[rule].keyswitch[idx].redirects[#n#].velocity := value_rule_keyswitch_redirect_key_velocity#n#
    end macro
    iterate_macro(update_keyswitch_config_redirect) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
end function


// EVENT HANDLERS

on ui_control(menu_global_cc_hanging)
    global_config[GLOBAL_CONFIG_CC_HANGING] := menu_global_cc_hanging
end on

// Selected rule changed
on ui_control(menu_rules)
    call gui_update_for_selected_rule
end on


// Add Rule button clicked
on ui_control(button_add)
    // Find empty available slot for rule
    idx := get_next_rule_idx()
    if idx = -1
        message("Can't add a new rule, already at limit of " & MAX_GUI_RULES)
    else
        initialize_rule(idx, "New Rule")
        set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
        set_menu_item_visibility(get_ui_id(menu_rules), idx, 1)
        menu_rules := idx
        call gui_update_for_selected_rule
    end if
    button_add := 0
end on


// Remove Rule button clicked
on ui_control(button_remove)
    rule := gui_get_selected_rule()
    // Determine closest adjacent rule to select next.
    target := -1
    for i := 0 to MAX_GUI_RULES - 1
        if rules[i].config[RULE_DEFINED] = 1 and i # rule and ...
         (target = -1 or abs(rule - i) < abs(rule - target))
            target := i
        end if
    end for
    if target = -1
        // This is the last rule, so rather than delete it, clear/reset it instead.
        initialize_rule(rule, "Your first rule - rename me!")
        set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
        call gui_update_for_selected_rule
    else
        rules[rule].config[RULE_DEFINED] := 0
        // TODO: vacuum rules list
        menu_rules := target
        set_menu_item_visibility(get_ui_id(menu_rules), rule, 0)
        call gui_update_for_selected_rule
        message("")
    end if
    button_remove := 0
end on

on ui_control(button_rule_clone)
    rule := gui_get_selected_rule()
    if rule >= 0
        // Find empty available slot for rule
        idx := get_next_rule_idx()
        if idx = -1
            message("Can't add a new rule, already at limit of " & MAX_GUI_RULES)
        else
            copy_rule(rule, idx)
            rules[idx].name := rules[rule].name & " +"
            set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
            set_menu_item_visibility(get_ui_id(menu_rules), idx, 1)
            menu_rules := idx
            call gui_update_for_selected_rule
        end if
    end if
    button_rule_clone := 0
end on


// Rule name text entry changed
on ui_control(text_rule_name)
    rule := gui_get_selected_rule()
    rules[rule].name := text_rule_name
    set_menu_item_str(get_ui_id(menu_rules), rule, text_rule_name)
end on


// Rule Bypass button clicked
on ui_control(button_rule_bypass)
    gui_set_selected_rule_config(RULE_ENABLED, 1 - button_rule_bypass)
    call gui_clear_active_routes_for_all_channels
end on


// Keyswitch channel menu changed
on ui_control(menu_rule_keyswitch_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_KEYSWITCH_CHANNEL, menu_rule_keyswitch_channel)
end on


// Source channel menu  changed
on ui_control(menu_rule_source_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_SOURCE_CHANNEL, menu_rule_source_channel)
end on


// Target channel menu  changed
on ui_control(menu_rule_target_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_TARGET_CHANNEL, menu_rule_target_channel)
end on

// CC chasing menu changed
on ui_control(menu_rule_cc_chasing)
    gui_set_selected_rule_config(RULE_CC_CHASING, menu_rule_cc_chasing)
    call gui_update_for_selected_rule
end on

// Selected keyswitch changed
on ui_control(menu_keyswitches)
    call gui_update_for_selected_keyswitch
end on


// Keyswitch New button clicked
on ui_control(button_keyswitch_new)
    ks := KEYSWITCH_UNDEFINED
    call gui_append_keyswitch_to_selected_rule
    button_keyswitch_new := 0
end on


// Keyswitch MIDI Learn button clicked
on ui_control(button_keyswitch_midi_learn)
    if button_keyswitch_midi_learn = 0
        need_maps_rebuild := 1
    else
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_learn := 1
    end if
end on


// Keyswitch MIDI Learn++ button clicked
on ui_control(button_keyswitch_midi_learn_inc)
    if button_keyswitch_midi_learn_inc = 0
        need_maps_rebuild := 1
    else
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_learn_inc := 1
    end if
end on

// Keyswitch Remove button clicked
on ui_control(button_keyswitch_remove)
    rule := gui_get_selected_rule()
    ks := gui_get_selected_keyswitch()

    // Clear current keyswitch
    rules[rule].keyswitch[ks].evcode := KEYSWITCH_UNDEFINED

    // Collapse all non-undefined rules down to be contiguous within the keyswitch array.
    // This is a bit more work than we might otherwise need to do, but due to an off-by-
    // one bug (fixed in 8ef7584) that resulted in the array becoming fragmented, we
    // do the more thorough job of collapsing the full array to retroactively fix those
    // arrays that ended up with gaps.
    //
    // Current index to store next non-undefined rule
    target := 0
    for source := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        if rules[rule].keyswitch[source].evcode # KEYSWITCH_UNDEFINED
            rules[rule].keyswitch[target].evcode := rules[rule].keyswitch[source].evcode
            name := get_keyswitch_name(rules[rule].keyswitch[source].evcode, rules[rule].keyswitch[source].velocity._raw)
            set_menu_item_str(get_ui_id(menu_keyswitches), target, name)
            set_menu_item_visibility(get_ui_id(menu_keyswitches), target, 1)
            for i := 0 to MAX_CONFIG_PER_KEYSWITCH - 1
                rules[rule].keyswitch[target].config[i] := rules[rule].keyswitch[source].config[i]
            end for
            for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                rules[rule].keyswitch[target].redirects[i]._raw := rules[rule].keyswitch[source].redirects[i]._raw
            end for
            target := target + 1
        end if
    end for
    // If we're on an item that we're now about to hide, set it to the last in the list.
    if menu_keyswitches >= target and target > 0
        menu_keyswitches := target - 1
    end if
    // Ensure everything after is wiped.
    for target := target to MAX_KEYSWITCHES_PER_RULE - 1
        rules[rule].keyswitch[target].evcode := KEYSWITCH_UNDEFINED
        for i := 0 to MAX_CONFIG_PER_KEYSWITCH - 1
            rules[rule].keyswitch[target].config[i] := -1
        end for
        for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
            rules[rule].keyswitch[target].redirects[i]._raw := KEYSWITCH_UNDEFINED
        end for
        set_menu_item_str(get_ui_id(menu_keyswitches), target, "<empty>")
        set_menu_item_visibility(get_ui_id(menu_keyswitches), target, 0)
    end for
    call gui_update_for_selected_keyswitch
    button_keyswitch_remove := 0
    need_maps_rebuild := 1
end on


// Keyswitch Redirect MIDI Learn button clicked
on ui_control(button_keyswitch_midi_find)
    if button_keyswitch_midi_find = 1
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_find := 1
    end if
end on

on ui_control(button_keyswitch_clone)
    ks := KEYSWITCH_UNDEFINED
    call gui_append_keyswitch_to_selected_rule
    button_keyswitch_clone := 0
end on

// Keyswitch Clear button clicked
on ui_control(button_keyswitch_clear)
    call gui_clear_keyswitches_for_selected_rule
    need_maps_rebuild := 1
    button_keyswitch_clear := 0
end on

// Keyswitch  type menu (key, CC, or program change) changed
on ui_control(menu_rule_keyswitch_type)
    if menu_rule_keyswitch_type = 0
         // FIXME: get next available key
        ks := 0
    else if menu_rule_keyswitch_type = 2
        // FIXME: get next available program
        ks := 128
    else
        // FIXME: get next available CC
        ks := 130*128 // CC-2 value 0
    end if
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    rules[rule].keyswitch[idx].evcode := ks
    call gui_update_for_selected_keyswitch
    call gui_update_keyswitch_name
end on


// Keyswitch note changed
on ui_control(value_rule_keyswitch_key)
    call gui_set_selected_keyswitch_from_ui
    need_maps_rebuild := 1
end on

// Keyswitch velocity range minimum changed
on ui_control(value_rule_keyswitch_velocity_range_min)
    call gui_set_selected_keyswitch_from_ui
end on


// Keyswitch velocity range maximum changed
on ui_control(value_rule_keyswitch_velocity_range_max)
    call gui_set_selected_keyswitch_from_ui
end on

// Keyswitch CC number changed
on ui_control(value_rule_keyswitch_cc)
    call gui_set_selected_keyswitch_from_ui
    need_maps_rebuild := 1
end on


// Keyswitch CC value changed
on ui_control(value_rule_keyswitch_cc_value_range_min)
    call gui_set_selected_keyswitch_from_ui
    need_maps_rebuild := 1
end on

on ui_control(value_rule_keyswitch_cc_value_range_max)
    call gui_set_selected_keyswitch_from_ui
    need_maps_rebuild := 1
end on


// Keyswitch program change number changed
on ui_control(value_rule_keyswitch_program)
    call gui_set_selected_keyswitch_from_ui
    need_maps_rebuild := 1
end on


// Keyswitch transpose changed
on ui_control(value_rule_keyswitch_transpose)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_TRANSPOSE, value_rule_keyswitch_transpose)
end on

// Keyswitch timing changed
on ui_control(value_rule_timing)
    gui_set_selected_keyswitch_config(RULE_TIMING, value_rule_timing)
end on

// Keyswitch action menu (block, passthrough, redirect) changed
on ui_control(menu_rule_keyswitch_action)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_ACTION, menu_rule_keyswitch_action)
    call gui_update_for_selected_keyswitch
end on


macro add_keyswitch_redirect_callbacks(#n#)
    on ui_control(button_rule_keyswitch_addremove#n#)
        rule := gui_get_selected_rule()
        idx := gui_get_selected_keyswitch()
        value := rules[rule].keyswitch[idx].redirects[#n#]._raw
        if value = KEYSWITCH_UNDEFINED
            // Duplicate previous keyswitch
            rules[rule].keyswitch[idx].redirects[#n#]._raw := rules[rule].keyswitch[idx].redirects[#n# - 1]._raw
        else
            // Move up everything below this keyswitch redirect
            for i := #n# to MAX_REDIRECTS_PER_KEYSWITCH - 2
                rules[rule].keyswitch[idx].redirects[i]._raw := rules[rule].keyswitch[idx].redirects[i + 1]._raw
                rules[rule].keyswitch[idx].redirects[i + 1]._raw := KEYSWITCH_UNDEFINED
            end for
        end if
        call gui_update_for_selected_keyswitch
        button_rule_keyswitch_addremove#n# := 0
    end on

    // Keyswitch redirect type menu (key or CC) changed
    on ui_control(menu_rule_keyswitch_redirect_type#n#)
        velocity := -1
        if menu_rule_keyswitch_redirect_type#n# = 0
            evcode := 0   { C-2 }
            velocity := 127
        else if menu_rule_keyswitch_redirect_type#n# = 2
            evcode := 128 { Prog 0 }
        else
            evcode := 130*128 { CC-2 value 0 }
        end if
        gui_set_selected_keyswitch_config_redirect(#n#, evcode, velocity)
        call gui_update_for_selected_keyswitch
    end on

    // Keyswitch redirect to note value changed
    on ui_control(value_rule_keyswitch_redirect_key#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch redirect to note velocity value changed
    on ui_control(value_rule_keyswitch_redirect_key_velocity#n#)
        gui_set_selected_keyswitch_config_redirect(#n#, -1, value_rule_keyswitch_redirect_key_velocity#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on


    // Keyswitch redirect to CC number changed
    on ui_control(value_rule_keyswitch_redirect_cc#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on


    // Keyswitch redirect to CC value
    on ui_control(value_rule_keyswitch_redirect_cc_value#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch redirect to CC value
    on ui_control(value_rule_keyswitch_redirect_program#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch Redirect MIDI Learn button clicked
    on ui_control(button_rule_keyswitch_redirect_midi_learn#n#)
        if keyswitch_redirect_midi_learn_index = #n#
            button_rule_keyswitch_redirect_midi_learn#n# := 0
            keyswitch_redirect_midi_learn_index := -1
        else
            call clear_redirect_midi_learn_buttons
            button_rule_keyswitch_redirect_midi_learn#n# := 1
            keyswitch_redirect_midi_learn_index := #n#
        end if
    end on
end macro
iterate_macro(add_keyswitch_redirect_callbacks) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1


// Keyswitch source channel value changed
on ui_control(menu_rule_keyswitch_source_channel)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_SOURCE_CHANNEL, menu_rule_keyswitch_source_channel)
    need_maps_rebuild := 1
    call gui_clear_active_routes_for_all_channels
end on

// Keyswitch target channel value changed
on ui_control(menu_rule_keyswitch_target_channel)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_TARGET_CHANNEL, menu_rule_keyswitch_target_channel)
    need_maps_rebuild := 1
    call gui_clear_active_routes_for_all_channels
end on

// Keyswitch flags changed
on ui_control(switch_rule_keyswitch_flags_hold_notes)
    gui_set_selected_keyswitch_config_flags(KEYSWITCH_FLAG_HOLD_NOTES, switch_rule_keyswitch_flags_hold_notes)
end on

on ui_control(switch_rule_keyswitch_flags_redirect_only)
    gui_set_selected_keyswitch_config_flags(KEYSWITCH_FLAG_IGNORE_ROUTING, switch_rule_keyswitch_flags_redirect_only)
end on
